
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Numerical computation of Riemann theta functions &#8212; Computing with adèles and idèles</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sage.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />
    <script src="_static/thebe.js" type="text/javascript"></script>
    <script src="_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Home</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Numerical computation of Riemann theta functions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-riemann_theta.riemann_theta"></span><section id="numerical-computation-of-riemann-theta-functions">
<h1>Numerical computation of Riemann theta functions<a class="headerlink" href="#numerical-computation-of-riemann-theta-functions" title="Permalink to this headline">¶</a></h1>
<p>This module implements arbitrary precision numerical computation of Riemann
theta functions with characteristics and their derivatives. We consider the following
definitions.</p>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(g\)</span> be a positive integer</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a <span class="math notranslate nohighlight">\(g\times g\)</span> <em>Riemann matrix</em>, i.e., a symmetric complex matrix with positive definite imaginary part.</p></li>
<li><p>A <em>characteristic</em> of level <span class="math notranslate nohighlight">\(N\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is a positive integer is a <span class="math notranslate nohighlight">\(2\times g\)</span> matrix with rows <span class="math notranslate nohighlight">\(\epsilon/N\)</span> and <span class="math notranslate nohighlight">\(\delta/N\)</span>. One normally only considers <em>reduced</em> characteristics, where the entries of <span class="math notranslate nohighlight">\(\epsilon,\delta\)</span> are in <span class="math notranslate nohighlight">\(\{0,\ldots,N-1\}\)</span>.</p></li>
</ul>
<p>For a row vector <span class="math notranslate nohighlight">\(z\in \Bold{C}^g\)</span> the <em>Riemann theta function</em> of <span class="math notranslate nohighlight">\(\Omega\)</span> evaluated
at <span class="math notranslate nohighlight">\(z\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\theta\begin{bmatrix} \epsilon/N\\\delta/N\end{bmatrix}(z,\Omega)=\sum_{n\in\Bold{Z}^g}e^{\pi i\left((n+\epsilon/N)\Omega(n+\epsilon/N)^T+2(n+\epsilon/N)(z+\delta/N)^T\right)}\end{split}\]</div>
<p>In addition, we also consider partial derivatives of Riemann theta functions with respect
to the components of <span class="math notranslate nohighlight">\(z\)</span>.</p>
<p>See <a class="reference internal" href="#dhbvhs2004" id="id1"><span>[DHBvHS2004]</span></a> and <a class="reference internal" href="#ac2019" id="id2"><span>[AC2019]</span></a> for a description of the basic description of the summation
strategy and the relevant error bounds that allow for efficient computation.
The main features of the present implementation are:</p>
<ul class="simple">
<li><p>It allows for multiprecision computations</p></li>
<li><p>It allows for characteristics and derivatives</p></li>
<li><p>The implementation is particularly optimized for computing multiple partial derivatives of a Riemann theta function with given characteristic and evaluation point.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>AUTHORS:</p>
<blockquote>
<div><ul class="simple">
<li><p>Nils Bruin, Sohrab Ganjian (2021-09-08): initial version</p></li>
</ul>
</div></blockquote>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="dhbvhs2004"><span class="brackets">DHBvHS2004</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>Bernard Deconinck, Matthias Heil, Alexander Bobenko, Mark van Hoeij, Marcus Schmies,
Computing Riemann Theta functions,
Math. Comp. 73-247 (2004): 1417-1442.</p>
</dd>
<dt class="label" id="ac2019"><span class="brackets">AC2019</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>Daniele Agostini, Lynn Chua,
Computing theta functions with Julia,
Journal of Software for Algebra and Geometry 11 (2021): 41-51</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormCholesky">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">NormCholesky</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.NormCholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for evaluating positive-definite norms.</p>
<p>For this class, the norm is given by the lower triangular cholesky
decomposition of the positive-definite Gram matrix of the norm. The class
is aimed at providing highly optimized action from cython, so functionality
on python level is limited.</p>
<dl class="py method">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormCholesky.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.NormCholesky.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return norm of vector.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – vector. Vector to compute norm of.</p></li>
</ul>
<p>OUTPUT: Norm of vector.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">NormCholesky</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RR</span><span class="o">=</span><span class="n">RealField</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">C</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="o">=</span><span class="n">NormCholesky</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">v</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="mf">34.000000000</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">v</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">v</span>
<span class="mf">34.000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormCholesky.init">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.NormCholesky.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize norm from lower triangular Cholesky decomposition.</p>
<p>Python-level wrapper.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> – real matrix. Matrix is assumed to be lower triangular.</p></li>
</ul>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">NormCholesky</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RR</span><span class="o">=</span><span class="n">RealField</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">C</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="o">=</span><span class="n">NormCholesky</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormGramInt">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">NormGramInt</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.NormGramInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for computation of norms of integer vectors given by a real-valued Gram matrix.</p>
<p>The class is aimed at providing highly optimized action from
cython, so functionality on python level is limited.</p>
<dl class="py method">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormGramInt.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.NormGramInt.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return norm of vector.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> – vector. Vector to compute norm of.</p></li>
</ul>
<p>OUTPUT: Norm of vector.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">NormGramInt</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RR</span><span class="o">=</span><span class="n">RealField</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="o">=</span><span class="n">NormGramInt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">v</span><span class="o">=</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="mf">37.000000000</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">v</span><span class="o">*</span><span class="n">G</span><span class="o">*</span><span class="n">v</span>
<span class="mf">37.000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.NormGramInt.init">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">init</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.NormGramInt.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize norm from Gram matrix.</p>
<p>Python-level wrapper.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – real matrix. Matrix is assumed to be lower triangular.</p></li>
</ul>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">NormGramInit</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RR</span><span class="o">=</span><span class="n">RealField</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span><span class="o">=</span><span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">nm</span><span class="o">=</span><span class="n">NormGramInt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.Rbound">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">Rbound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.Rbound" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute radius for Riemann theta function summation.</p>
<p>See Theorem 2 in <a class="reference internal" href="#dhbvhs2004" id="id3"><span>[DHBvHS2004]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Y</span></code> – real matrix. Positive definite (imaginary part of a Riemann matrix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> – real number. Tolerance for error allowed in theta function summation.</p></li>
</ul>
<p>OUTPUT: radius for summation to restrict error term to be within specified tolerance.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">Rbound</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Rbound</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="mi">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="mf">5.70985786129</span><span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.Rbound_deriv">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">Rbound_deriv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.Rbound_deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute radius for Riemann theta function summation with derivatives.</p>
<p>See Theorem 3.1 in <a class="reference internal" href="#ac2019" id="id4"><span>[AC2019]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Y</span></code> – real matrix. Positive definite (imaginary part of a Riemann matrix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> – integer. Order of derivative.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code> – real number. Tolerance for error allowed in theta function summation.</p></li>
</ul>
<p>OUTPUT: radius for summation to restrict error term to be within specified tolerance.</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">Rbound_deriv</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Rbound_deriv</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="mf">6.6689474473</span><span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.RiemannTheta">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">RiemannTheta</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.RiemannTheta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object for numerical computation of Riemann Theta functions with characteristics and derivatives</p>
<p>INPUT:
- <code class="docutils literal notranslate"><span class="pre">Omega</span></code> – Complex matrix. The Riemann matrix for which to compute</p>
<blockquote>
<div><p>Riemann Theta functions. The precision of the base ring determines the default
tolerance used in computing Riemann Theta function values.</p>
</div></blockquote>
<p>EXAMPLES:</p>
<p>We go through a very simple example that illustrates the basic features.
First we define the Riemann matrix and its RiemannTheta object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">RiemannTheta</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">CC</span><span class="o">=</span><span class="n">ComplexField</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Omega</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">I</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="o">=</span><span class="n">RiemannTheta</span><span class="p">(</span><span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the object evaluates the theta nullwerte, but we can specify
the value of <span class="math notranslate nohighlight">\(z\)</span> at which we want to evaluate. Theta functions are fully
periodic under translation by integer vectors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">()</span>
<span class="mf">1.000161700487241998</span><span class="o">...</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="mf">1.000161700487241998</span><span class="o">...</span>
</pre></div>
</div>
<p>The Riemann theta function is even, so its first order partial derivatives
are zero. We also demonstrate we can compute them as a vector in one go.
Note that partial derivatives are indicated by the index with respect to which
the partial derivative should be taken:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">derivs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="mf">0.00000000000000000000000</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">derivs</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="mf">0.00000000000000000000000</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">derivs</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span>
<span class="p">(</span><span class="mf">0.00000000000000000000000</span><span class="p">,</span> <span class="mf">0.00000000000000000000000</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also compute higher order derivatives, so the following gives us the
hessian matrix at <code class="docutils literal notranslate"><span class="pre">z=0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">RT</span><span class="p">(</span><span class="n">derivs</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="p">[</span>  <span class="o">-</span><span class="mf">0.0063717804307107830675222</span>     <span class="o">-</span><span class="mf">0.00000000000000000000000</span><span class="p">]</span>
<span class="p">[</span>    <span class="o">-</span><span class="mf">0.00000000000000000000000</span> <span class="o">-</span><span class="mf">0.000011900851943023954077279</span><span class="p">]</span>
</pre></div>
</div>
<p>Characteristics can be given as <code class="docutils literal notranslate"><span class="pre">[[delta_1,...,delta_g],[eps_1,...,eps_g],N]]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">N</span></code> gives the level and the <code class="docutils literal notranslate"><span class="pre">delta_i,</span> <span class="pre">eps_i</span></code> are integers specifying
the characteristic. Alternatively, one can give the characteristic as a
<code class="docutils literal notranslate"><span class="pre">2g</span></code>-dimensional vector over <code class="docutils literal notranslate"><span class="pre">Z/NZ</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">char</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># abs_tol = 1e-24</span>
<span class="mf">1.2071813646649472697563e-25</span> <span class="o">-</span> <span class="mf">2.8725542860550068599620e-26</span><span class="o">*</span><span class="n">I</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">char</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># abs_tol = 1e-24</span>
<span class="mf">1.2071813646649472697563e-25</span> <span class="o">-</span> <span class="mf">2.8725542860550068599620e-26</span><span class="o">*</span><span class="n">I</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">char</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">derivs</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]])</span> <span class="c1"># abs_tol = 1e-24</span>
<span class="p">(</span><span class="o">-</span><span class="mf">0.59552188399685576910149</span> <span class="o">-</span> <span class="mf">1.1412196198763623205771e-49</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5185834728040112058953e-32</span> <span class="o">+</span> <span class="mf">2.5226254523149252440284e-56</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>We check that for the genus 2 curve <span class="math notranslate nohighlight">\(C: y^2=(x-2)*(x-3)*(x-5)*(x-7)*(x-11)*(x-13)\)</span>,
the gradients of the odd theta characteristics of level 2 are proportional to the
roots <span class="math notranslate nohighlight">\(2, 3, 5, 7, 11, 13\)</span>. We give a period matrix for this curve relative to a
cohomology basis that is defined over <span class="math notranslate nohighlight">\(Q\)</span>, derive the Riemann matrix, compute the
gradients of the odd characteristics (with respect to the original cohomology basis!)
and check that the ratios give us back the roots listed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">RiemannTheta</span>
<span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">sage.schemes.riemann_surfaces.riemann_surface</span> <span class="k">import</span> <span class="n">numerical_inverse</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span> <span class="o">-</span><span class="mf">0.100985221999616</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0576741242160428</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.170602500958820</span><span class="p">,</span> <span class="mf">0.137052375058957</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.257755342052576</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.684089137456259</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">0.685128296898840</span><span class="p">,</span> <span class="mf">1.18843441146637</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Omega1</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Omega2</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Omega1i</span> <span class="o">=</span> <span class="n">numerical_inverse</span><span class="p">(</span><span class="n">Omega1</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">Omega</span> <span class="o">=</span> <span class="n">Omega1i</span><span class="o">*</span><span class="n">Omega2</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">odd</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">4</span> <span class="k">if</span> <span class="n">v</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span> <span class="o">=</span> <span class="n">RiemannTheta</span><span class="p">(</span><span class="n">Omega</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">gradients</span> <span class="o">=</span> <span class="p">[</span><span class="n">vector</span><span class="p">(</span><span class="n">RT</span><span class="p">(</span><span class="n">derivs</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">]],</span><span class="n">char</span><span class="o">=</span><span class="n">c</span><span class="p">))</span><span class="o">*</span><span class="n">Omega1i</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">odd</span><span class="p">]</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">([(</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">algdep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">gradients</span><span class="p">])</span>
<span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">11</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">7</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.RiemannTheta.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.RiemannTheta.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate Riemann theta function with characteristic and derivatives.</p>
<p>INPUT:
- <code class="docutils literal notranslate"><span class="pre">z</span></code> – vector; optional (default 0). Point to evaluate theta function at.
- <code class="docutils literal notranslate"><span class="pre">char</span></code> – list or vector; optional (default 0). Characteristic.</p>
<blockquote>
<div><p>The characteristic can either be specified as a list
<code class="docutils literal notranslate"><span class="pre">[[delta_1,</span> <span class="pre">...,</span> <span class="pre">delta_g],[eps_1,</span> <span class="pre">...,eps_g],N]</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the level
of the characteristic and the <code class="docutils literal notranslate"><span class="pre">delta_i,</span> <span class="pre">eps_j</span></code> are integers describing the
characteristic, or as a <code class="docutils literal notranslate"><span class="pre">2*g`-dimensional</span> <span class="pre">vector</span> <span class="pre">over</span> <span class="pre">``ZZ/</span> <span class="pre">N*ZZ</span></code>. In the latter case,
the level <code class="docutils literal notranslate"><span class="pre">N</span></code> is read off from the base ring and the vector is taken to be
<code class="docutils literal notranslate"><span class="pre">[delta_1,</span> <span class="pre">...,</span> <span class="pre">delta_g,</span> <span class="pre">eps_1,</span> <span class="pre">...,</span> <span class="pre">eps_g]</span></code>.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">derivs</span></code> – list; optional (default []). Derivatives. It can be a list</dt><dd><p>of integers <code class="docutils literal notranslate"><span class="pre">[i_1,...,i_n]</span></code>, in which case it is taken to mean the derivative of
order <code class="docutils literal notranslate"><span class="pre">n</span></code>, obtained by taking the partial derivative with respect to
<code class="docutils literal notranslate"><span class="pre">z[i_1],</span> <span class="pre">...,</span> <span class="pre">z[i_n]</span></code>. Alternatively, it can be a list of lists of integers,
in which case the values of the derivatives indicated by the members of the list
are returned as a tuple, in order.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tol</span></code> – real number; optional. Tolerance allowed in approximation. The default is</dt><dd><p>the tolerance indicated by the precision of the base ring. Note that the tolerance
controlled is the tolerance in the approximation of the periodic part of the Riemann
Theta function (see <a class="reference internal" href="#dhbvhs2004" id="id5"><span>[DHBvHS2004]</span></a>). Furthermore, floating point rounding in iterated
summations may perturb the lower bits.</p>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT: A complex number of a tuple of them; the value(s) of the indicated Riemann
Theta function(s).</p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">RiemannTheta</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="o">=</span><span class="n">RiemannTheta</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">CC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">]))</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RT</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">char</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">],</span><span class="n">derivs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="c1"># abs_tol = 1e-15</span>
<span class="mf">2.88494706892332e-16</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.Vector_long">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">Vector_long</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.Vector_long" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Vector of system “long” integers</p>
<p>This is only a very thin wrapper to give Cython code efficient access
to an array of “long” that can be placed in Python data structures,
so implemented functionality is minimal and almost none of it is
available outside of cython.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.Vector_mpc">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">Vector_mpc</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.Vector_mpc" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Vector of mpc complex numbers.</p>
<p>This is only a very thin wrapper to give Cython code efficient access
to an array of “mpc_t” that can be placed in Python data structures,
so implemented functionality is minimal and almost none of it is
available outside of cython.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.Vector_mpfr">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">Vector_mpfr</span></span><a class="headerlink" href="#riemann_theta.riemann_theta.Vector_mpfr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Vector of mpfr reals.</p>
<p>This is only a very thin wrapper to give Cython code efficient access
to an array of “mpfr_t” that can be placed in Python data structures,
so implemented functionality is minimal and almost none of it is
available outside of cython.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.cholesky_decomposition">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">cholesky_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.cholesky_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Cholesky decomposition of a positive definite real matrix.</p>
<p>The Cholesky decomposition of a real positive definite matrix <span class="math notranslate nohighlight">\(G\)</span> is
a lower triangular matrix <span class="math notranslate nohighlight">\(G\)</span> such that <span class="math notranslate nohighlight">\(G = C C^T\)</span>.</p>
<p>This routine wraps the multiprecision implementation in the mp library.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – real matrix. Positive definite.</p></li>
</ul>
<p>OUTPUT: The cholesky decomposition <code class="docutils literal notranslate"><span class="pre">C</span></code> such that <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">==</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">C.T</span></code></p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">cholesky_decomposition</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">RR</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">RR</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">C</span> <span class="o">=</span> <span class="n">cholesky_decomposition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">sage</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="mf">0.00000000000000000000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.imag_func">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">imag_func</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.imag_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return result of calling <code class="docutils literal notranslate"><span class="pre">imag</span></code> method on argument.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – object</p></li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">a.imag()</span></code></p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">imag_func</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">imag_func</span><span class="p">(</span><span class="n">CC</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
<span class="mf">1.00000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.real_func">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">real_func</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.real_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return result of calling <code class="docutils literal notranslate"><span class="pre">real</span></code> method on argument.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – object</p></li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">a.real()</span></code></p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">real_func</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">real_func</span><span class="p">(</span><span class="n">CC</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span>
<span class="mf">0.000000000000000</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="riemann_theta.riemann_theta.round_func">
<span class="sig-prename descclassname"><span class="pre">riemann_theta.riemann_theta.</span></span><span class="sig-name descname"><span class="pre">round_func</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#riemann_theta.riemann_theta.round_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return result of calling <code class="docutils literal notranslate"><span class="pre">round</span></code> method on argument.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – object</p></li>
</ul>
<p>OUTPUT: <code class="docutils literal notranslate"><span class="pre">a.round()</span></code></p>
<p>EXAMPLE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sage</span><span class="p">:</span> <span class="kn">from</span> <span class="nn">riemann_theta</span> <span class="k">import</span> <span class="n">round_func</span>
<span class="n">sage</span><span class="p">:</span> <span class="n">round_func</span><span class="p">(</span><span class="mf">2.7</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/riemann_theta.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Home</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Numerical computation of Riemann theta functions</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Nils Bruin.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.1.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>